{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport fs from 'fs';\nimport matter from 'gray-matter';\nimport mdxPrism from 'mdx-prism';\nimport path from 'path';\nimport readingTime from 'reading-time';\nimport renderToString from 'next-mdx-remote/render-to-string';\nimport MDXComponents from '@/components/MDXComponents';\nconst root = process.cwd();\nexport async function getFiles(type) {\n  return fs.readdirSync(path.join(root, 'data', type));\n}\nexport async function getFileBySlug(type, slug) {\n  const source = slug ? fs.readFileSync(path.join(root, 'data', type, `${slug}.mdx`), 'utf8') : fs.readFileSync(path.join(root, 'data', `${type}.mdx`), 'utf8');\n  const {\n    data,\n    content\n  } = matter(source);\n  const mdxSource = await renderToString(content, {\n    components: MDXComponents,\n    mdxOptions: {\n      remarkPlugins: [require('remark-autolink-headings'), require('remark-slug'), require('remark-code-titles')],\n      rehypePlugins: [mdxPrism]\n    }\n  });\n  return {\n    mdxSource,\n    frontMatter: _objectSpread({\n      wordCount: content.split(/\\s+/gu).length,\n      readingTime: readingTime(content),\n      slug: slug || null\n    }, data)\n  };\n}\nexport async function getAllFilesFrontMatter(type) {\n  const files = fs.readdirSync(path.join(root, 'data', type));\n  return files.reduce((allPosts, postSlug) => {\n    const source = fs.readFileSync(path.join(root, 'data', type, postSlug), 'utf8');\n    const {\n      data\n    } = matter(source);\n    return [_objectSpread(_objectSpread({}, data), {}, {\n      slug: postSlug.replace('.mdx', '')\n    }), ...allPosts];\n  }, []);\n}","map":null,"metadata":{},"sourceType":"module"}